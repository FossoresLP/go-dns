package response

import (
	"reflect"
	"testing"

	"github.com/fossoreslp/go-dns/dns/label"
	"github.com/fossoreslp/go-dns/dns/record-names"
	"github.com/fossoreslp/go-dns/dns/record-types"
)

func TestResponse_String(t *testing.T) {
	tests := []struct {
		name string
		r    Response
		want string
	}{
		{"Normal", Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, nil}, "Record for \"example.com.\", Type: A, Class: IN, TTL: 3600, Data length: 4, Data: 00000000"},
		{"Unknown type", Response{label.Label{"example", "com"}, names.TYPE(16000), names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, nil}, "Record for \"example.com.\", Type: 16000, Class: IN, TTL: 3600, Data length: 4, Data: 00000000"},
		{"Unknown class", Response{label.Label{"example", "com"}, names.CNAME, names.CLASS(16000), 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, nil}, "Record for \"example.com.\", Type: CNAME, Class: 16000, TTL: 3600, Data length: 4, Data: 00000000"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.r.String(); got != tt.want {
				t.Errorf("Response.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestParse(t *testing.T) {
	type args struct {
		message    []byte
		start      int
		answers    uint16
		ns         uint16
		additional uint16
	}
	tests := []struct {
		name           string
		args           args
		wantAnswers    []Response
		wantNS         []Response
		wantAdditional []Response
		wantErr        bool
	}{
		{"Normal", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1, 1, 1}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, false},
		{"Answer parsing failed", args{[]byte{}, 0, 1, 1, 1}, nil, nil, nil, true},
		{"NS parsing failed", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1, 1, 1}, nil, nil, nil, true},
		//{"Additional parsing failed", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1, 1, 1}, nil, nil, nil, true},
		{"No answers", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 0, 1, 1}, nil, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, false},
		{"No NS", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1, 0, 1}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, nil, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, false},
		{"No additional", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1, 1, 0}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, nil, false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotAnswers, gotNS, gotAdditional, err := Parse(tt.args.message, tt.args.start, tt.args.answers, tt.args.ns, tt.args.additional)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotAnswers, tt.wantAnswers) {
				t.Errorf("Parse() gotAnswers = %v, want %v", gotAnswers, tt.wantAnswers)
			}
			if !reflect.DeepEqual(gotNS, tt.wantNS) {
				t.Errorf("Parse() gotNS = %v, want %v", gotNS, tt.wantNS)
			}
			if !reflect.DeepEqual(gotAdditional, tt.wantAdditional) {
				t.Errorf("Parse() gotAdditional = %v, want %v", gotAdditional, tt.wantAdditional)
			}
		})
	}
}

func Test_parseSection(t *testing.T) {
	type args struct {
		message  []byte
		start    int
		elements uint16
	}
	tests := []struct {
		name    string
		args    args
		wantOut []Response
		wantEnd int
		wantErr bool
	}{
		{"No responses", args{nil, 0, 0}, nil, 0, false},
		{"Normal", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1}, []Response{Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, &record.A{IPv4: [4]byte{0x0, 0x0, 0x0, 0x0}}}}, 27, false},
		{"Label parsing failed", args{[]byte{0x40, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}, 0, 1}, nil, 0, true},
		{"Message too short for RR info", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00}, 0, 1}, nil, 0, true},
		{"Data exceeds message length", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04}, 0, 1}, nil, 0, true},
		{"Data parsing error", args{[]byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x02, 0x00, 0x00}, 0, 1}, nil, 0, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotOut, gotEnd, err := parseSection(tt.args.message, tt.args.start, tt.args.elements)
			if (err != nil) != tt.wantErr {
				t.Errorf("parseSection() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotOut, tt.wantOut) {
				t.Errorf("parseSection() gotOut = %v, want %v", gotOut, tt.wantOut)
			}
			if gotEnd != tt.wantEnd {
				t.Errorf("parseSection() gotEnd = %v, want %v", gotEnd, tt.wantEnd)
			}
		})
	}
}

func Test_getRecordType(t *testing.T) {
	tests := []struct {
		name string
		typ  names.TYPE
		want record.Record
	}{
		{"Default", names.TYPE(16000), nil},
		{"A", names.A, new(record.A)},
		{"AAAA", names.AAAA, new(record.AAAA)},
		{"CAA", names.CAA, new(record.CAA)},
		{"CNAME", names.CNAME, new(record.CNAME)},
		{"MX", names.MX, new(record.MX)},
		{"NS", names.NS, new(record.NS)},
		{"PTR", names.PTR, new(record.PTR)},
		{"SOA", names.SOA, new(record.SOA)},
		{"SRV", names.SRV, new(record.SRV)},
		{"TXT", names.TXT, new(record.TXT)},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := getRecordType(tt.typ); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("getRecordType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestNew(t *testing.T) {
	type args struct {
		name label.Label
		t    names.TYPE
		ttl  uint32
		data []byte
	}
	tests := []struct {
		name string
		args args
		want Response
	}{
		{"Normal", args{label.Label{"example", "com"}, names.A, 3600, []byte{0x0, 0x0, 0x0, 0x0}}, Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, nil}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := New(tt.args.name, tt.args.t, tt.args.ttl, tt.args.data); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("New() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestResponse_Encode(t *testing.T) {
	tests := []struct {
		name string
		r    Response
		want []byte
	}{
		{"Normal", Response{label.Label{"example", "com"}, names.A, names.IN, 3600, 4, []byte{0x0, 0x0, 0x0, 0x0}, nil}, []byte{0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0E, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.r.Encode(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Response.Encode() = %v, want %v", got, tt.want)
			}
		})
	}
}
